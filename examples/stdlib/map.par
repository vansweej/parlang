type List a = Nil | Cons a (List a) in
type Option a = Some a | None in
type Tuple k v = Tuple k v in
type Map k v = List (Tuple k v) in
let empty = Nil in
let insert = fun key -> fun value -> fun map ->
  let delete_key = rec delete_key -> fun k -> fun m ->
    match m with
    | Nil -> Nil
    | Cons pair rest ->
        (match pair with
        | Tuple pk pv -> 
            if pk == k then rest
            else Cons pair (delete_key k rest))
  in
  Cons (Tuple key value) (delete_key key map)
in
let lookup = rec lookup -> fun key -> fun map ->
  match map with
  | Nil -> None
  | Cons pair rest ->
      (match pair with
      | Tuple k v ->
          if k == key then Some v
          else lookup key rest)
in
let delete = rec delete -> fun key -> fun map ->
  match map with
  | Nil -> Nil
  | Cons pair rest ->
      (match pair with
      | Tuple k v ->
          if k == key then rest
          else Cons pair (delete key rest))
in
let member = fun key -> fun map ->
  match lookup key map with
  | Some _ -> true
  | None -> false
in
let size = rec size -> fun map ->
  match map with
  | Nil -> 0
  | Cons _ rest -> 1 + size rest
in
let keys = rec keys -> fun map ->
  match map with
  | Nil -> Nil
  | Cons pair rest ->
      (match pair with
      | Tuple k _ -> Cons k (keys rest))
in
let values = rec values -> fun map ->
  match map with
  | Nil -> Nil
  | Cons pair rest ->
      (match pair with
      | Tuple _ v -> Cons v (values rest))
in
let to_list = fun map -> map in
let from_list = rec from_list -> fun list ->
  match list with
  | Nil -> empty
  | Cons pair rest ->
      (match pair with
      | Tuple k v -> insert k v (from_list rest))
in
let map_values = rec map_values -> fun f -> fun m ->
  match m with
  | Nil -> Nil
  | Cons pair rest ->
      (match pair with
      | Tuple k v -> Cons (Tuple k (f v)) (map_values f rest))
in
let filter = rec filter -> fun pred -> fun m ->
  match m with
  | Nil -> Nil
  | Cons pair rest ->
      (match pair with
      | Tuple k v ->
          if pred k v then Cons pair (filter pred rest)
          else filter pred rest)
in
let fold = rec fold -> fun f -> fun acc -> fun m ->
  match m with
  | Nil -> acc
  | Cons pair rest ->
      (match pair with
      | Tuple k v -> fold f (f acc k v) rest)
in
let demo = 
  let m0 = empty in
  let m1 = insert 1 42 m0 in
  let m2 = insert 2 30 m1 in
  let m3 = insert 3 95 m2 in
  let name_val = lookup 1 m3 in
  let missing = lookup 99 m3 in
  let has_name = member 1 m3 in
  let has_missing = member 99 m3 in
  let map_size = size m3 in
  let m4 = insert 2 31 m3 in
  let m5 = delete 3 m4 in
  let all_keys = keys m5 in
  let all_values = values m5 in
  let m6 = map_values (fun x -> x * 2) m5 in
  let m7 = filter (fun k -> fun v -> v > 50) m6 in
  let sum = fold (fun acc -> fun k -> fun v -> acc + v) 0 m6 in
  sum
in
demo
